---
layout: single
title:  "Word Wrap"
date:   2024-02-08 16:40:00 +0530
categories: programming
---

For the history and the journey of the dynamic programming approach please refer to earlier article [longest-common-subsequence](https://sivarambattu.github.io/programming/2024/01/29/longest-common-subsequence.html)

I tried to follow similar path as the LCS problem, but it was challenging to figure out what is the exact problem that fall in the dynamic programming domain.
Finally settled on this Wikipedia subsection [Word Wrap - minimum raggedness](https://en.wikipedia.org/wiki/Line_wrap_and_word_wrap#Minimum_raggedness)
*"minimizes the sum of the squares of the lengths of the spaces at the end of lines"*. We ignore the space in the last line, not to penalize the paragraph endings.

An example(Wikipedia):  
For the input text `AAA BB CC DDDDD` and maximum length of line as `6`. If we go with greedy approach, we get `4^2 = 16`
```
------    Line width: 6
AAA BB    Remaining space: 0
CC        Remaining space: 4
DDDDD     Remaining space: Ignored in last line
```
If we try a different approach we get `3^2 + 1^2 = 10`
```
------    Line width: 6
AAA       Remaining space: 3
BB CC     Remaining space: 1
DDDDD     Remaining space: Ignored in last line
```

Formulating the approach at the high level:
- If there are no words at all, it's just empty we can return cost as 0
```
    if len(word_lens) == 0:
        return 0
```
- If there are words, we place a word at the beginning of the line, if its the first word, we don't calculate the penalty yet
because if its the only word on that line and we end right there, we ignore the cost of space in last line, but if we end up
placing another word, we can calculate the remaining distance at that point. There might be better way to track it, one way 
I am tracking this is by keep tracking of remaining length in each line, so if remaining length is equal to total length of the line, we assume its first word.
```
    if remain_len == line_len:
        # This is the first word, lets place it and proceed with rest
        return word_wrap(word_lens[1:], line_len, line_len - word_lens[0])
```
- The next scenario to handle is if placing the word in the current line is going to exceed the line, place it in next line.
When we are placing the next line, we can now calculate the cost of the remaining space in the current line and keep track of that total.
Since we are moving to the next line, we reset our remaining line length the full line length.
```
    if word_lens[0] + 1 > remain_len:
        # The current word can't fit on this line, go to next line
        return pow(remain_len, 2) + word_wrap(word_lens, line_len, line_len)
```
- Now that we handled fringe cases, we get to the core of minimizing cost part, if this is not the first word in the line and if the word can fit in current line,
we have two choices to make, either to place in current line or in the next line.
When placing on the current line, we have to remove the current word length from remaining length and also an extra space(-1) that we are going to place between words.
If we place it on next line, we need to consider the cost of the remaining length.
```
        return min(
            word_wrap(word_lens[1:], line_len, remain_len - 1 - word_lens[0]), # current line
            pow(remain_len, 2) + word_wrap(word_lens, line_len, line_len), # next line
        )
```

Gluing these together yields our version1

## Version 1 - Recursive solution
```
def word_wrap_v1(word_lens: List, line_len: int) -> int:
    """
    Given a list of words and the maximum line length, return minimum cost of arranging.
    Cost = The sum of squared differences b/w line_len & remaining spaces.
    Assumptions: None of the words in the input list are over the line limit(line_len).
    """
    def word_wrap(word_lens: List, line_len: int, remain_len: int) -> int:
        if len(word_lens) == 0:
            return 0
        
        if remain_len == line_len:
            # This is the first word, lets place it and proceed with rest
            return word_wrap(word_lens[1:], line_len, line_len - word_lens[0])
        
        if word_lens[0] + 1 > remain_len:
            # The current word can't fit on this line, go to next line
            return pow(remain_len, 2) + word_wrap(word_lens, line_len, line_len)
        
        return min(
            word_wrap(word_lens[1:], line_len, remain_len - 1 - word_lens[0]), # current line
            pow(remain_len, 2) + word_wrap(word_lens, line_len, line_len), # next line
        )

    return word_wrap(word_lens, line_len, line_len)   
```

It works perfect for smaller examples but runs forever once we increase input size

```
print(word_wrap_v1([3, 2, 2, 5]*20, 6))
```
This input takes forever

## Version 2 - Recursion with cache

- There is a slight catch with trying to place the cache decorator in front of our recursive function.
We can only if all the arguments are hashable(unmutable), but the passed in word_lens list is mutable type.
One way I got around this is to serialize the array as JSON string while passing in and deserialize it within the function before using it.

```
from functools import cache
import json

def word_wrap_v2(word_lens: List, line_len: int) -> int:
    """
    Given a list of words and the maximum line length, return minimum cost of arranging.
    Cost = The sum of squared differences b/w line_len & remaining spaces.
    Assumptions: None of the words in the input list are over the line limit(line_len).
    """
    @cache
    def word_wrap(word_lens: str, line_len: int, remain_len: int) -> int:
        word_lens = json.loads(word_lens)
        if len(word_lens) == 0:
            return 0
        
        if remain_len == line_len:
            # This is the first word, lets place it and proceed with rest
            return word_wrap(json.dumps(word_lens[1:]), line_len, line_len - word_lens[0])
        
        if word_lens[0] + 1 > remain_len:
            # The current word can't fit on this line, go to next line
            return pow(remain_len, 2) + word_wrap(json.dumps(word_lens), line_len, line_len)
        
        return min(
            word_wrap(json.dumps(word_lens[1:]), line_len, remain_len - 1 - word_lens[0]), # current line
            pow(remain_len, 2) + word_wrap(json.dumps(word_lens), line_len, line_len), # next line
        )

    return word_wrap(json.dumps(word_lens), line_len, line_len)  
```

This goes through bigger examples with a breeze

```
# print(word_wrap_v2([3, 2, 2, 5]*20, 6))
# 219
# python3 word_wrap.py  0.02s user 0.01s system 80% cpu 0.042 total
```

```
# print(word_wrap_v2([3, 2, 2, 5]*40, 6))
# 439
# python3 word_wrap.py  0.03s user 0.01s system 95% cpu 0.036 total
```


# Version 3 - Recursion with cache without JSON serialization

In this iteration, got away with the string serialization and used word_lens list index to keep track of where I am.

```
def word_wrap_v3(word_lens: List, line_len: int) -> int:
    """
    Given a list of words and the maximum line length, return minimum cost of arranging.
    Cost = The sum of squared differences b/w line_len & remaining spaces.
    Assumptions: None of the words in the input list are over the line limit(line_len).
    """
    @cache
    def word_wrap(word_lens_idx: int, remain_len: int) -> int:
        if word_lens_idx == len(word_lens):
            return 0
        
        if remain_len == line_len:
            # This is the first word, lets place it and proceed with rest
            return word_wrap(word_lens_idx + 1, line_len - word_lens[word_lens_idx])
        
        if word_lens[word_lens_idx] + 1 > remain_len:
            # The current word can't fit on this line, go to next line
            return pow(remain_len, 2) + word_wrap(word_lens_idx, line_len)
        
        return min(
            word_wrap(word_lens_idx + 1, remain_len - 1 - word_lens[word_lens_idx]), # current line
            pow(remain_len, 2) + word_wrap(word_lens_idx, line_len), # next line
        )

    return word_wrap(0, line_len)    

```

We are still holding good on runtime

# print(word_wrap_v3([3, 2, 2, 5]*20, 6))
# 219
# python3 word_wrap.py  0.02s user 0.01s system 85% cpu 0.026 total
```

```
# print(word_wrap_v3([3, 2, 2, 5]*40, 6))
# 439
# python3 word_wrap.py  0.02s user 0.01s system 94% cpu 0.029 total```
```

# Version 4 - Iterative version (our own cache)

```
def word_wrap_v4(word_lens: List, line_len: int) -> int:
    """
    Given a list of words and the maximum line length, return minimum cost of arranging.
    Cost = The sum of squared differences b/w line_len & remaining spaces.
    Assumptions: None of the words in the input list are over the line limit(line_len).
    """

    cache = [[None]*(line_len+1) for _ in range(len(word_lens)+1)]

    for word_lens_idx in range(len(word_lens), -1, -1):
        for remain_len in range(line_len, -1, -1):
            if word_lens_idx == len(word_lens):
                cache[word_lens_idx][remain_len] = 0
            elif remain_len == line_len:
                cache[word_lens_idx][remain_len] = cache[word_lens_idx+1][line_len - word_lens[word_lens_idx]]
            elif word_lens[word_lens_idx] + 1 > remain_len:
                cache[word_lens_idx][remain_len] = pow(remain_len, 2) + cache[word_lens_idx][line_len]
            else:
                cache[word_lens_idx][remain_len] = min(
                    cache[word_lens_idx + 1][remain_len - 1 - word_lens[word_lens_idx]],
                    pow(remain_len, 2) + cache[word_lens_idx + 1][line_len - word_lens[word_lens_idx]]
                )

    return cache[0][0]
```

## What Next
Subset sum program